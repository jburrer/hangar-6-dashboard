{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/home/n3mo/Documents/hangar-6-dashboard-new/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/home/n3mo/Documents/hangar-6-dashboard-new/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"/home/n3mo/Documents/hangar-6-dashboard-new/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"/home/n3mo/Documents/hangar-6-dashboard-new/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"/home/n3mo/Documents/hangar-6-dashboard-new/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport { rename, writeFile } from 'node:fs/promises';\nimport { basename, dirname, join } from 'node:path';\nimport { fileURLToPath } from 'node:url';\n// Returns a temporary file\n// Example: for /some/file will return /some/.file.tmp\nfunction getTempFilename(file) {\n  const f = file instanceof URL ? fileURLToPath(file) : file.toString();\n  return join(dirname(f), \".\".concat(basename(f), \".tmp\"));\n}\n// Retries an asynchronous operation with a delay between retries and a maximum retry count\nasync function retryAsyncOperation(fn, maxRetries, delayMs) {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (i < maxRetries - 1) {\n        await new Promise(resolve => setTimeout(resolve, delayMs));\n      } else {\n        throw error; // Rethrow the error if max retries reached\n      }\n    }\n  }\n}\nvar _filename = /*#__PURE__*/new WeakMap();\nvar _tempFilename = /*#__PURE__*/new WeakMap();\nvar _locked = /*#__PURE__*/new WeakMap();\nvar _prev = /*#__PURE__*/new WeakMap();\nvar _next = /*#__PURE__*/new WeakMap();\nvar _nextPromise = /*#__PURE__*/new WeakMap();\nvar _nextData = /*#__PURE__*/new WeakMap();\nvar _Writer_brand = /*#__PURE__*/new WeakSet();\nexport class Writer {\n  constructor(filename) {\n    // File is locked, add data for later\n    _classPrivateMethodInitSpec(this, _Writer_brand);\n    _classPrivateFieldInitSpec(this, _filename, void 0);\n    _classPrivateFieldInitSpec(this, _tempFilename, void 0);\n    _classPrivateFieldInitSpec(this, _locked, false);\n    _classPrivateFieldInitSpec(this, _prev, null);\n    _classPrivateFieldInitSpec(this, _next, null);\n    _classPrivateFieldInitSpec(this, _nextPromise, null);\n    _classPrivateFieldInitSpec(this, _nextData, null);\n    _classPrivateFieldSet(_filename, this, filename);\n    _classPrivateFieldSet(_tempFilename, this, getTempFilename(filename));\n  }\n  async write(data) {\n    return _classPrivateFieldGet(_locked, this) ? _assertClassBrand(_Writer_brand, this, _add).call(this, data) : _assertClassBrand(_Writer_brand, this, _write).call(this, data);\n  }\n}\nfunction _add(data) {\n  // Only keep most recent data\n  _classPrivateFieldSet(_nextData, this, data);\n  // Create a singleton promise to resolve all next promises once next data is written\n  _classPrivateFieldGet(_nextPromise, this) || _classPrivateFieldSet(_nextPromise, this, new Promise((resolve, reject) => {\n    _classPrivateFieldSet(_next, this, [resolve, reject]);\n  }));\n  // Return a promise that will resolve at the same time as next promise\n  return new Promise((resolve, reject) => {\n    var _classPrivateFieldGet2;\n    (_classPrivateFieldGet2 = _classPrivateFieldGet(_nextPromise, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.then(resolve).catch(reject);\n  });\n}\n// File isn't locked, write data\nasync function _write(data) {\n  // Lock file\n  _classPrivateFieldSet(_locked, this, true);\n  try {\n    var _classPrivateFieldGet3;\n    // Atomic write\n    await writeFile(_classPrivateFieldGet(_tempFilename, this), data, 'utf-8');\n    await retryAsyncOperation(async () => {\n      await rename(_classPrivateFieldGet(_tempFilename, this), _classPrivateFieldGet(_filename, this));\n    }, 10, 100);\n    // Call resolve\n    (_classPrivateFieldGet3 = _classPrivateFieldGet(_prev, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3[0]();\n  } catch (err) {\n    // Call reject\n    if (err instanceof Error) {\n      var _classPrivateFieldGet4;\n      (_classPrivateFieldGet4 = _classPrivateFieldGet(_prev, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4[1](err);\n    }\n    throw err;\n  } finally {\n    // Unlock file\n    _classPrivateFieldSet(_locked, this, false);\n    _classPrivateFieldSet(_prev, this, _classPrivateFieldGet(_next, this));\n    _classPrivateFieldSet(_next, this, _classPrivateFieldSet(_nextPromise, this, null));\n    if (_classPrivateFieldGet(_nextData, this) !== null) {\n      const nextData = _classPrivateFieldGet(_nextData, this);\n      _classPrivateFieldSet(_nextData, this, null);\n      await this.write(nextData);\n    }\n  }\n}","map":{"version":3,"names":["rename","writeFile","basename","dirname","join","fileURLToPath","getTempFilename","file","f","URL","toString","concat","retryAsyncOperation","fn","maxRetries","delayMs","i","error","Promise","resolve","setTimeout","_filename","WeakMap","_tempFilename","_locked","_prev","_next","_nextPromise","_nextData","_Writer_brand","WeakSet","Writer","constructor","filename","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateFieldSet","write","data","_classPrivateFieldGet","_assertClassBrand","_add","call","_write","reject","_classPrivateFieldGet2","then","catch","_classPrivateFieldGet3","err","Error","_classPrivateFieldGet4","nextData"],"sources":["/home/n3mo/Documents/hangar-6-dashboard-new/node_modules/steno/lib/index.js"],"sourcesContent":["import { rename, writeFile } from 'node:fs/promises';\nimport { basename, dirname, join } from 'node:path';\nimport { fileURLToPath } from 'node:url';\n// Returns a temporary file\n// Example: for /some/file will return /some/.file.tmp\nfunction getTempFilename(file) {\n    const f = file instanceof URL ? fileURLToPath(file) : file.toString();\n    return join(dirname(f), `.${basename(f)}.tmp`);\n}\n// Retries an asynchronous operation with a delay between retries and a maximum retry count\nasync function retryAsyncOperation(fn, maxRetries, delayMs) {\n    for (let i = 0; i < maxRetries; i++) {\n        try {\n            return await fn();\n        }\n        catch (error) {\n            if (i < maxRetries - 1) {\n                await new Promise((resolve) => setTimeout(resolve, delayMs));\n            }\n            else {\n                throw error; // Rethrow the error if max retries reached\n            }\n        }\n    }\n}\nexport class Writer {\n    #filename;\n    #tempFilename;\n    #locked = false;\n    #prev = null;\n    #next = null;\n    #nextPromise = null;\n    #nextData = null;\n    // File is locked, add data for later\n    #add(data) {\n        // Only keep most recent data\n        this.#nextData = data;\n        // Create a singleton promise to resolve all next promises once next data is written\n        this.#nextPromise ||= new Promise((resolve, reject) => {\n            this.#next = [resolve, reject];\n        });\n        // Return a promise that will resolve at the same time as next promise\n        return new Promise((resolve, reject) => {\n            this.#nextPromise?.then(resolve).catch(reject);\n        });\n    }\n    // File isn't locked, write data\n    async #write(data) {\n        // Lock file\n        this.#locked = true;\n        try {\n            // Atomic write\n            await writeFile(this.#tempFilename, data, 'utf-8');\n            await retryAsyncOperation(async () => {\n                await rename(this.#tempFilename, this.#filename);\n            }, 10, 100);\n            // Call resolve\n            this.#prev?.[0]();\n        }\n        catch (err) {\n            // Call reject\n            if (err instanceof Error) {\n                this.#prev?.[1](err);\n            }\n            throw err;\n        }\n        finally {\n            // Unlock file\n            this.#locked = false;\n            this.#prev = this.#next;\n            this.#next = this.#nextPromise = null;\n            if (this.#nextData !== null) {\n                const nextData = this.#nextData;\n                this.#nextData = null;\n                await this.write(nextData);\n            }\n        }\n    }\n    constructor(filename) {\n        this.#filename = filename;\n        this.#tempFilename = getTempFilename(filename);\n    }\n    async write(data) {\n        return this.#locked ? this.#add(data) : this.#write(data);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}